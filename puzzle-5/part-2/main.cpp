#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <time.h>

void getSeeds(std::map<long long, long long>  &, std::ifstream &);
void getRanges(std::map<long long, long long> &, std::ifstream &);
void updateRanges(std::map<long long, long long> &, std::map<long long, std::vector<long long>> &);

void printMap(std::map<long long, std::vector<long long>> &);
void printRanges(std::map<long long, long long> &); //used to print the seed map for verification

int main(){
    std::clock_t t = std::clock();

    std::string file_name = "./puzzle-5.txt";
    std::ifstream file(file_name);

    int num_ranges = 0;

    std::map<long long, long long> ranges; //ordered left bound with the range value in the value pair, 
    getSeeds(ranges, file); //initializes ranges with the seed ranges

    num_ranges = ranges.size();

    /*
        Algorithm to get the smallest location value possible with the seeds:
        1. Grab Seed Ranges represented by [Left][Range]
        2. Grab the Transformation Map (seed-to-fert map) and then process the ranges map (adjust, remove, update left and range pairs) 
            based on the output ranges from the transformation map
        3. Repeat for all Transformation Maps
        4. At the end, the Top element of the ranges map will be the answer to this part 
    */

   getRanges(ranges, file);

   
   std::cout << "answer is: " << ranges.begin()->first << " with "<< ranges.size() << " ranges as compared to the original " << num_ranges << " seed ranges!" << std::endl;

    //system("pause");
    std::cout << "Total Execution time: " <<  (std::clock() - t ) / (float)CLOCKS_PER_SEC << " seconds" << std::endl;
    return 0;
}

void getSeeds(std::map<long long, long long> &map, std::ifstream &file){
    //generate the first line containing the list of seeds
    std::string line;
    std::getline(file, line);

    //create and initialize three iterator values pointing to the start of the numbers
    auto itr = std::next(line.begin(),7);
    auto start = itr;
    auto end = itr;

    /*
    go position to position on the string, if the value the iterator is pointing at is 
    the " " space delimiter, then push that long long number into the vector
    */
    long long temp = 0;
    while(itr != line.end()){
        if(!isdigit(*itr)){
            end = itr; //updated end to the current iterator position
            if(temp != 0){
                map[temp] = stoll(std::string(start, end));//capture the next long long integer value as the range representation
                temp = 0;
            }else{
                temp = stoll(std::string(start, end));//grab the long long generated by stoll (string to long long) as the left bound
            }
            start = itr + 1; //update the start to be the iterator after the current iterator
        }
        itr++; //update the driving iterator
    }
    end = line.end(); //update the end to the end of the string
    map[temp] = stoll(std::string(start, end));//capture the next long long integer value as the range representation
    return;
}

//continues reading the file where getRanges left off
//processes a block of digits which represents some sort of conversion like seeds->soil and udates the ranges using the updateRanges() function
//to update the ranges for the next iteration. This will continue until the end of file is found.
void getRanges(std::map<long long, long long> &ranges, std::ifstream &file){
    std::string line;

    std::map<long long, std::vector<long long>> map; //stores the transformation matrix used to process ranges.
    bool data_flag = false; //false until a number is found
    bool endof_file = false; //test to see if the end of the file was found eventually

    std::vector<long long> temp; //temp place to store the individual values from the line

    //add iterators to help pull the numbers from the line
    auto itr = line.begin();
    auto start = itr;
    auto end = itr;

    //go row by row and capture the data of the form [output][input][range] and transform it to an input map [left-bound][right-bound][differnce between input and output]
    while(!endof_file){
        map.clear();
        //makes sure that the row iterator is pointing at the next row of digits 
        while(!data_flag){
            std::getline(file, line);
            if(isdigit(line[0])) data_flag = true;
        }

        itr = line.begin();
        start = itr;
        end = itr;

        while(data_flag){
            //capture the [output][input][range] in the vector<long long> temp
            while(itr != line.end()){
                if(!isdigit(*itr)){
                    end = itr; //updated end to the current iterator position
                    temp.push_back(stoll(std::string(start, end))); //push the long long generated by stoll (string to long long)
                    start = itr + 1; //update the start to be the iterator after the current iterator
                }
                itr++; //update the driving iterator
            }
            end = line.end();
            temp.push_back(stoll(std::string(start, end)));
            
            //transform [output][input][range] into [left-bound][range][output - input] which realistically means [input][range][diff] and insert into the map
            map[temp[1]] = {temp[2], temp[0] - temp[1]};

            //clean up variables to be reused
            temp.clear();

            //get line on next iteration or break loop when the next line is blank or we reach the end of the file
            if(std::getline(file, line)){
                if(!isdigit(line[0])) data_flag = false;
                itr = line.begin();
                start = itr;
                end = itr;
            }else{
                data_flag = false;
                endof_file = true;
            }
        }
        updateRanges(ranges, map);
    }
    return;
}

/*
    So this is gonna be a bit complicated...
    Once we receive an input range from std::map ranges (iterated by using a for each loop)
    We have a map iterator for maps and we move from top to bottom until the left bound of the input range is less than the
    left bound + range of the map iterator. From here there are a couple states to be careful of and different behaviors:
    State 1: Range occurs before Map_range
    State 2: Range starts before Map_Range and extends into Map_Range
    State 3: Range starts before Map_Range and extends beyond Map_Range
    State 4: Range starts within Map_Range and ends within Map_Range
    State 5: Range starts within Map_Range and ends outside of Map_Range
    State 6: Range starts beyond Map_Range
*/
void updateRanges(std::map<long long, long long> &ranges, std::map<long long, std::vector<long long>> &map){
    std::map<long long, long long> temp_ranges;
    auto it = map.begin();

    long long range_leftbound;
    long long range_range;
    long long range_rightbound;
    long long map_leftbound;
    long long map_range;
    long long map_rightbound;
    long long map_outdiff;
    bool next_range = false;

    for(auto& range: ranges){
        next_range = false;

        //grab the range values to be processed
        range_leftbound = range.first;
        range_range = range.second;
        range_rightbound = range.first + range.second - 1;

        while(!next_range){ //keep processing until the next range is called
            //grab most recent version of map
            
            if(it != map.end()){
                map_leftbound = it->first;
                map_range = it->second[0];
                map_rightbound = it->first + it->second[0] - 1;
                map_outdiff = it->second[1];
            }

            //begin processing the different states - these will split up the input ranges into output ranges
            if(range_leftbound < map_leftbound){
                if(range_rightbound < map_leftbound){
                    temp_ranges[range_leftbound] = range_range;
                    next_range = true;
                }else if(range_rightbound <= map_rightbound){
                    temp_ranges[range_leftbound] = map_leftbound - range_leftbound;
                    temp_ranges[map_leftbound + map_outdiff] = range_rightbound - map_leftbound + 1;
                    
                    if(range_rightbound == map_rightbound){
                        it++;
                    }else{
                        map[range_rightbound + 1] = {map_rightbound - range_rightbound, map_outdiff};
                        it++;
                    }
                    next_range = true;
                }else if(range_rightbound > map_rightbound){
                    temp_ranges[range_leftbound] = map_leftbound - range_leftbound;
                    temp_ranges[map_leftbound + map_outdiff] = map_range;
                    range_leftbound = map_rightbound + 1;
                    range_range = range_rightbound - range_leftbound + 1;
                    it++;
                }
            }else if(range_leftbound > map_rightbound){
                if(it != map.end()){
                    it++;
                }else{
                    temp_ranges[range_leftbound] = range_range;
                    next_range = true;
                }
            }else if(range_leftbound >= map_leftbound){
                if(range_rightbound <= map_rightbound){
                    temp_ranges[range_leftbound + map_outdiff] = range_range;
                    if(range_rightbound == map_rightbound){
                        it++;
                    }else{
                        map[range_rightbound + 1] = {map_rightbound - range_rightbound, map_outdiff};
                        it++;
                    }
                    next_range = true;
                }else if(range_rightbound > map_rightbound){
                    temp_ranges[range_leftbound + map_outdiff] = map_rightbound - range_leftbound;
                    range_leftbound = map_rightbound + 1;
                    range_range = range_rightbound - range_leftbound + 1;
                    if(it != map.end()){
                        it++;
                    }
                } 
            }  
        }
    }
    ranges = temp_ranges;
    return;
}


long long getMapOutput(std::map<long long, std::vector<long long>> &map, long long input){
    for(auto& pair: map){
        if(input < pair.first) return input; //compares input to left bound, in all cases, if input is less than the left bound, then we can assume that the value isnt covered by the table and can be return as just input
        else if(input >= pair.first && input <= pair.second[0]) return input + pair.second[1]; //if the input lies within the leftbound and the right bound, we can then add the output differential to the input
    }
    return LLONG_MAX;
}

void printMap(std::map<long long, std::vector<long long>> &map){
    long long leftBound = 0; long long rightBound = 0; long long outputDiff = 0;
    std::vector<long long> values;
    for(auto& pair: map){
        leftBound = pair.first;
        values = pair.second;

        // Access individual elements
        rightBound = values[0];
        outputDiff = values[1];

        std::cout << leftBound << " " << rightBound << " " << outputDiff << std::endl;
    }
    std::cout << std::endl;
    return;
}

void printRanges(std::map<long long, long long> &map){
    long long leftBound = 0; long long range = 0;
    std::vector<long long> values;
    for(auto& pair: map){
        leftBound = pair.first;
        range = pair.second;

        std::cout << "Left Bound: " <<leftBound << " Range: " << range << std::endl;
    }
    std::cout << std::endl;
    return;
}