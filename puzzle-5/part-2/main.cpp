#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>

void getSeeds(std::vector<long long> &, std::ifstream &);
void getMap(std::map<long long, std::vector<long long>> &, std::ifstream &);
long long getMapOutput(std::map<long long, std::vector<long long>> &, long long);
void printMap(std::map<long long, std::vector<long long>> &);

int main(){
    std::string file_name = "../../../puzzle-5.txt";
    std::vector<long long> seeds;
    std::map<long long, std::vector<long long>> map_seed2soil;
    std::map<long long, std::vector<long long>> map_soil2fert;
    std::map<long long, std::vector<long long>> map_fert2water;
    std::map<long long, std::vector<long long>> map_water2light;
    std::map<long long, std::vector<long long>> map_light2temp;
    std::map<long long, std::vector<long long>> map_temp2humidity;
    std::map<long long, std::vector<long long>> map_humidity2location;

    std::string line;
    std::ifstream file(file_name);

    //fill vector<long long> seeds with the list of seeds
    getSeeds(seeds, file);

    //get all information from the puzzle, process the array from [output, input, range] to [input range left bound, input range right bound, input -> output change]
    getMap(map_seed2soil, file);
    getMap(map_soil2fert, file);
    getMap(map_fert2water, file);
    getMap(map_water2light, file);
    getMap(map_light2temp, file);
    getMap(map_temp2humidity, file);
    getMap(map_humidity2location, file);

    //using getMapOutput to interpret the corresponding map, the following function spits out the location by following the transitions from seed->soil->fert->water->light->temp->humidity->location
    //then compare that location with the current smallest location
    long long location;
    long long smallest_location = LLONG_MAX; //initial value is the largest possible value of long long as a means of defining the first "smallest" values as the first location returned
    for(auto seed: seeds){
        location = getMapOutput(map_humidity2location, 
                   getMapOutput(map_temp2humidity, 
                   getMapOutput(map_light2temp, 
                   getMapOutput(map_water2light, 
                   getMapOutput(map_fert2water, 
                   getMapOutput(map_soil2fert,
                   getMapOutput(map_seed2soil, seed)))))));
        std::cout << location << " ";
        if(location < smallest_location) smallest_location = location;
    }
    std::cout << std::endl;
    //figure out a method for breaking apart the mapping data into an algorithm

    std::cout << smallest_location << std::endl;
    //system("pause");
    return 0;
}


void getSeeds(std::vector<long long> &arr, std::ifstream &file){
    //generate the first line containing the list of seeds
    std::string line;
    std::getline(file, line);

    //create and initialize three iterator values pointing to the start of the numbers
    auto itr = std::next(line.begin(),7);
    auto start = itr;
    auto end = itr;

    /*
    go position to position on the string, if the value the iterator is pointing at is 
    the " " space delimiter, then push that long long number into the vector
    */
    while(itr != line.end()){
        if(!isdigit(*itr)){
            end = itr; //updated end to the current iterator position
            arr.push_back(stoll(std::string(start, end))); //push the long long generated by stoll (string to long long)
            start = itr + 1; //update the start to be the iterator after the current iterator
        }
        itr++; //update the driving iterator
    }
    end = line.end(); //update the end to the end of the string
    arr.push_back(stoll(std::string(start, end))); //capture the next long long integer value
    
    return;
}

//continues reading the file where getSeeds left off or where the previous call of this function is left off
//processes a block of digits which represents some sort of conversion like seeds->soil
void getMap(std::map<long long, std::vector<long long>> &map, std::ifstream &file){
    std::string line;
    bool data_flag = false; //false until a number is found
    
    //makes sure that the row iterator is pointing at the next row of digits 
    while(!data_flag){
        std::getline(file, line);
        if(isdigit(line[0])) data_flag = true;
    }

    std::vector<long long> temp; //temp place to store the individual values from the line
    //add iterators to help pull the numbers from the line
    auto itr = line.begin();
    auto start = itr;
    auto end = itr;

    //go row by row and capture the data of the form [output][input][range] and transform it to an input map [left-bound][right-bound][differnce between input and output]
    while(data_flag){
        //capture the [output][input][range] in the vector<long long> temp
        while(itr != line.end()){
            if(!isdigit(*itr)){
                end = itr; //updated end to the current iterator position
                temp.push_back(stoll(std::string(start, end))); //push the long long generated by stoll (string to long long)
                start = itr + 1; //update the start to be the iterator after the current iterator
            }
            itr++; //update the driving iterator
        }
        end = line.end();
        temp.push_back(stoll(std::string(start, end)));
        
        //transform [output][input][range] into [left-bound][right-bound][output - input] which realistically means [input][input+range-1][output-input] and insert into the map
        map[temp[1]] = {temp[1] + temp[2] - 1, temp[0] - temp[1]};

        //clean up variables to be reused
        temp.clear();

        //get line on next iteration or break loop when the next line is blank or we reach the end of the file
        if(std::getline(file, line)){
            if(!isdigit(line[0])) data_flag = false;
            itr = line.begin();
            start = itr;
            end = itr;
        }else{
            data_flag = false;
        }
    }
    printMap(map);
    return;
}

long long getMapOutput(std::map<long long, std::vector<long long>> &map, long long input){
    for(auto& pair: map){
        if(input < pair.first) return input; //compares input to left bound, in all cases, if input is less than the left bound, then we can assume that the value isnt covered by the table and can be return as just input
        else if(input >= pair.first && input <= pair.second[0]) return input + pair.second[1]; //if the input lies within the leftbound and the right bound, we can then add the output differential to the input
    }
    return LLONG_MAX;
}

void printMap(std::map<long long, std::vector<long long>> &map){
    long long leftBound = 0; long long rightBound = 0; long long outputDiff = 0;
    std::vector<long long> values;
    for(auto& pair: map){
        leftBound = pair.first;
        values = pair.second;

        // Access individual elements
        rightBound = values[0];
        outputDiff = values[1];

        std::cout << leftBound << " " << rightBound << " " << outputDiff << std::endl;
    }
    std::cout << std::endl;
    return;
}